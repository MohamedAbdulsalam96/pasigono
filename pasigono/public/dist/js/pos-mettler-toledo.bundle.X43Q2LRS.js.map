{
  "version": 3,
  "sources": ["../../../../../apps/pasigono/pasigono/custom_scripts/pos_scripts/pos_mettler_toledo.js"],
  "sourcesContent": ["var port;\nvar textEncoder;\nvar weight = 0;\nvar weightLoop = false;\nvar portConnected = false;\nvar reader;\n/*window.writer;\nerpnext.PointOfSale.Toledo.connect = async function(){\n\twindow.port = await navigator.serial.getPorts();\n\tawait window.port.open({baudRate: 9600, dataBits: 7, parity: \"even\", stopBits: 1});\n\treceiveData();\n\tconst textEncoder = new TextEncoderStream();\n\ttextEncoder.readable.pipeTo(window.port.writable);\n\twindow.writer = textEncoder.writable.getWriter();\n\twindow.setInterval(getweight, 1000);\n}\n\nerpnext.PointOfSale.Toledo.getWeight = async function(){\n\tasync function getweight(){\n\t\t// Prompt user to select any serial port.\n\t\tawait window.writer.write(\"W\");\n\t}\n}*/\n\nonmessage = function(message){\n\tif(message.data.command == \"connect\"){\n\t\tconnectPort();\n\t}\n    else if(message.data.command == \"start\")\n    {\n\t\tconsole.log(\"Start called\");\n\t\tweightLoop = true;\n        startWeight();\n    }\n\telse if(message.data.command == \"stop\"){\n\t\tweightLoop = false;\n\t}\n}\n\nasync function connectPort(){\n\tvar portFound = false;\n    var ports = await navigator.serial.getPorts();\n\ttextEncoder = new TextEncoderStream();\n\tif(ports.length > 0){\n\t\t\n\t\tport = ports[0];\n\t\tvar stop = false;\n\t\ttry{\n\t\t\tawait port.open({baudRate: 9600, dataBits: 7, parity: \"even\", stopBits: 1});\n\t\t\ttextEncoder.readable.pipeTo(port.writable);\n\t\t\treader = port.readable.getReader();\n\t\t\tportConnected = true;\n\t\t}\n\t\tcatch(error){\n\t\t\t//TODO: Catch connection errors\n\t\t}\n\t}\n}\n\nasync function startWeight(){\n\tif(portConnected){\n\t\tconsole.log(\"Port connected\");\n\t\ttry{\n\t\t\tvar strWeight = \"\";\n\t\t\tawait sendCommand(\"W\");\n\t\t}catch(error){\n\t\t\t//TODO: Catch error if port already connected\n\t\t}\n\t\twhile(port.readable){\n\t\t\tif(!weightLoop){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttry{\n\t\t\t\twhile(true){\n\t\t\t\t\tif(!weightLoop){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst {value, done} = await reader.read();\n\t\t\t\t\tif(done){\n\t\t\t\t\t\t//reader.releaseLock();\n\t\t\t\t\t}\n\t\t\t\t\tif(value){\n\t\t\t\t\t\tvar [response, completed] = await decodeData(value);\n\t\t\t\t\t\tif(!completed){\n\t\t\t\t\t\t\tstrWeight.concat(response);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t//If all the result is returned in a single chunk\n\t\t\t\t\t\t\tif(strWeight == \"\"){\n\t\t\t\t\t\t\t\tstrWeight = response;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tstrWeight.concat(response)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar newWeight = parseFloat(strWeight);\n\t\t\t\t\t\t\tconsole.log({\"new weight\": newWeight});\n\t\t\t\t\t\t\tif(newWeight != weight && !isNaN(newWeight)){\n\t\t\t\t\t\t\t\tweight = newWeight;\n\t\t\t\t\t\t\t\tpostMessage({\n\t\t\t\t\t\t\t\t\t\"message\": \"weight\",\n\t\t\t\t\t\t\t\t\t\"weight\": weight\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsetTimeout(async function(){\n\t\t\t\t\t\t\t\t//Wait for 500ms to give the weight device time to process result \n\t\t\t\t\t\t\t\t//and give script time to accept new command\n\t\t\t\t\t\t\t\tstrWeight = \"\";\n\t\t\t\t\t\t\t\tawait sendCommand(\"W\");\n\t\t\t\t\t\t\t}, 500);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}catch(error){\n\t\t\t\t//TODO: Catch errors relating to writing and reading from port\n\t\t\t\tconsole.log(error.message);\n\t\t\t} finally{\n\t\t\t\t//reader.releaseLock();\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\t//TODO: Call function to connect device then read weight\n\t}\n}\n\nasync function sendCommand(command){\n\ttry{\n\t\tvar writer = textEncoder.writable.getWriter();\n\t\tawait writer.write(command);\n\t\twriter.releaseLock();\n\t\t//writer.close();\n\t}\n\tcatch(error){\n\t\tconsole.log(error.message);\n\t}\n}\n\nasync function decodeData(data){\n\tvar str = \"\";\n\tvar completed = false;\n\tfor(var i = 0; i < data.byteLength; i++){\n\t\t//Check if the value is not the ASCII STR (Start of Text) character\n\t\t//Or is an ASCII cr indicating that the weight has been completely sent\n\t\tif(data[i] != 2){\n\t\t\tif(data[i] == 13){\n\t\t\t\tcompleted = true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstr = str.concat(String.fromCharCode(data[i]));\n\t\t\t}\n\t\t}\n\t}\n\treturn [str, completed];\n}\n\n"],
  "mappings": "MAAA,GAAI,GACA,EACA,EAAS,EACT,EAAa,GACb,EAAgB,GAChB,EAmBJ,UAAY,SAAS,EAAQ,CAC5B,AAAG,EAAQ,KAAK,SAAW,UAC1B,EAAY,EAEL,AAAG,EAAQ,KAAK,SAAW,QAElC,SAAQ,IAAI,cAAc,EAC1B,EAAa,GACP,EAAY,GAEX,EAAQ,KAAK,SAAW,QAC/B,GAAa,GAEf,EAEA,kBAA4B,CAC3B,GAAI,GAAY,GACT,EAAQ,KAAM,WAAU,OAAO,SAAS,EAE/C,GADA,EAAc,GAAI,mBACf,EAAM,OAAS,EAAE,CAEnB,EAAO,EAAM,GACb,GAAI,GAAO,GACX,GAAG,CACF,KAAM,GAAK,KAAK,CAAC,SAAU,KAAM,SAAU,EAAG,OAAQ,OAAQ,SAAU,CAAC,CAAC,EAC1E,EAAY,SAAS,OAAO,EAAK,QAAQ,EACzC,EAAS,EAAK,SAAS,UAAU,EACjC,EAAgB,EACjB,OACM,EAAN,CAEA,CACD,CACD,CAEA,kBAA4B,CAC3B,GAAG,EAAc,CAChB,QAAQ,IAAI,gBAAgB,EAC5B,GAAG,CACF,GAAI,GAAY,GAChB,KAAM,GAAY,GAAG,CACtB,OAAO,EAAN,CAED,CACA,KAAM,EAAK,UACN,GAGJ,GAAG,CACF,KACK,GADM,CAIV,GAAM,CAAC,QAAO,QAAQ,KAAM,GAAO,KAAK,EAIxC,GAAG,EAAM,CACR,GAAI,CAAC,EAAU,GAAa,KAAM,GAAW,CAAK,EAClD,GAAG,CAAC,EACH,EAAU,OAAO,CAAQ,MAEtB,CAEH,AAAG,GAAa,GACf,EAAY,EAGZ,EAAU,OAAO,CAAQ,EAE1B,GAAI,GAAY,WAAW,CAAS,EACpC,QAAQ,IAAI,CAAC,aAAc,CAAS,CAAC,EAClC,GAAa,GAAU,CAAC,MAAM,CAAS,GACzC,GAAS,EACT,YAAY,CACX,QAAW,SACX,OAAU,CACX,CAAC,GAEF,WAAW,gBAAgB,CAG1B,EAAY,GACZ,KAAM,GAAY,GAAG,CACtB,EAAG,GAAG,CACP,CACD,CACD,CACD,OAAO,EAAN,CAEA,QAAQ,IAAI,EAAM,OAAO,CAC1B,QAAE,CAEF,CAEF,CAID,CAEA,iBAA2B,EAAQ,CAClC,GAAG,CACF,GAAI,GAAS,EAAY,SAAS,UAAU,EAC5C,KAAM,GAAO,MAAM,CAAO,EAC1B,EAAO,YAAY,CAEpB,OACM,EAAN,CACC,QAAQ,IAAI,EAAM,OAAO,CAC1B,CACD,CAEA,iBAA0B,EAAK,CAG9B,OAFI,GAAM,GACN,EAAY,GACR,EAAI,EAAG,EAAI,EAAK,WAAY,IAGnC,AAAG,EAAK,IAAM,GACb,CAAG,EAAK,IAAM,GACb,EAAY,GAGZ,EAAM,EAAI,OAAO,OAAO,aAAa,EAAK,EAAE,CAAC,GAIhD,MAAO,CAAC,EAAK,CAAS,CACvB",
  "names": []
}
